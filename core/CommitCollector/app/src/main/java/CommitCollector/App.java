/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package CommitCollector;

import org.apache.commons.cli.*;
import java.io.*;
import java.util.*;
import org.eclipse.jgit.api.*;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        Options options = new Options();
        Option[] option = new Option[4];

        boolean isDefects4j = false;
        String defects4jBug = new String();
        String hashID = new String();
        String bugInfoFile = new String();

        Properties bugProps = new Properties();
        String projectName = new String();
        String projectLink = new String();
        String faultyPath = new String();
        String faultyLineFix = new String();
        String faultyLineBlame = new String();
        String buggyCommit = new String();

        String root = System.getProperty("user.dir");

        Project targetProject;

        // String 

        // options[0] = new Option("d", "defects4j", "Tells that hte input argument is Defects4J Bug.", false);
        option[0] = Option.builder("d").longOpt("defects4j")
            .hasArg().argName("defects4jBug")
            .desc("Tells that Defects4J Bug is passed as an argument.").build();
        // option[1] = Option.builder("i").longOpt("input")
        //     .hasArg().argName("directInput")
        //     .desc("Tells that arguments are passed directly.").build();
        option[1] = Option.builder("f").longOpt("file")
            .hasArg().argName("bugInfoFile")
            .desc("Tells that defect properties are directly given via .properties file.").build();
        option[2] = Option.builder("i").longOpt("hash")
            .required()
            .hasArg().argName("hashID")
            .desc("Tells that previously made byproducts will be used.").build();
        option[3] = Option.builder("h").longOpt("help")
            .desc("Prints out this help message.").build();

        for(int i = 0; i < option.length; i++)  options.addOption(option[i]);

        CommandLineParser parser = new DefaultParser();
        try
        {
            CommandLine line = parser.parse(options, args);

            if(line.hasOption("help"))
            {
                System.out.println("Help requested.");
                
                HelpFormatter formatter = new HelpFormatter();
                formatter.printHelp("CommitCollector", options);

                System.exit(0);
            }

            if(line.hasOption("hash"))
            {
                hashID = line.getOptionValue("hash");
                System.out.printf("Hash ID set as %s\n", hashID);
            }
            if(line.hasOption("file"))
            {
                // bugInfoFile = String.format("%s%s%s", root, File.pathSeparator, line.getOptionValue("input"));
                bugInfoFile = String.format("%s/%s", root, line.getOptionValue("input"));
            }
            if(line.hasOption("defects4j"))
            {
                projectName = line.getOptionValue("defects4j");
                // defects4jBug = line.getOptionValue("defects4j");
                isDefects4j = true;
                System.out.printf("Defects4J bug \"%s\" used.\n", projectName);
            }
            else System.out.println("No arguments given.");
        }
        catch (ParseException ex)
        {
            System.err.println("Parsing failed. Reason: " + ex.getMessage());
            ex.printStackTrace();
        }

        // String targetDir = String.format("%s%starget%s%s", root, File.pathSeparator, File.pathSeparator,hashID);
        // String outputDir = String.format("%s%soutputs", targetDir, File.pathSeparator);
        String targetDir = String.format("%s/target/%s", root, hashID);
        String outputDir = String.format("%s/outputs", targetDir);

        File targetDirPath = new File(targetDir);
        File outputDirPath = new File(outputDir);

        if(!targetDirPath.mkdirs())
        {
            System.err.println("mkdirs for target directory failed.");
            System.exit(-1);
        }
        if(!outputDirPath.mkdirs())
        {
            System.err.println("mkdirs for output directory failed.");
            System.exit(-1);
        }

        targetProject = (isDefects4j) ? (new Defects4JProject()) : (new GitHubProject());

        if(isDefects4j)
        {
            targetProject = new Defects4JProject();
        }
        else
        {
            targetProject = new GitHubProject();
        }

       if(!isDefects4j && !bugInfoFile.equals(""))
       {
            try
            {
                bugProps.load(new FileInputStream(bugInfoFile));
            }
            catch (FileNotFoundException e)
            {
                e.printStackTrace();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            // System.out.printf("Direct input requested, as %s\n", bugInfoFile);

            projectName     = bugProps.getProperty("projectName");
            projectLink     = bugProps.getProperty("projectLink");
            faultyPath      = bugProps.getProperty("faultyPath");
            faultyLineFix   = bugProps.getProperty("faultyLineFix");
            faultyLineBlame = bugProps.getProperty("faultyLineBlame");
            buggyCommit     = bugProps.getProperty("buggyCommit");

            try
            {
                Git.cloneRepository()
                    .setURI(projectLink)
                    .setDirectory(targetDirPath).call();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
       }
       else if(isDefects4j)
       {
            String[] bug_id = projectName.split("-");
            // read csv file.

            // projectName      =
            // projectLink      =
            // faultyPath       =
            // faultyLineFix    = 
            // faultyLineBlame  = 
            // buggyCommit      = 
       }


        // if(bugInfoFile.equals("")) // Direct input not given
        // {
        //     // String d4jCSVPath = String.format("");
        //     // File d4jCSV = new File("");


        // }
        // else
        // {
        // }



        // System.out.println(new App().getGreeting());
    }
}
